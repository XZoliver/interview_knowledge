# 数据库面试题

## 基础

**说一说三个范式**

第一范式: 每个列都不可以再拆分. 

第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分.

 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.

**什么是SQL注入攻击？**
> todo

**drop,delete与truncate的区别**

+ drop：删除内容和定义，释放空间。（表结构和数据一同删除）
+ delete：删除数据，实际上空间不会被释放，只是标记了一下，下一次插入数据可以把这条记录给覆盖掉
+ truncate：删除内容，释放空间，但不删除定义。（表结构还在，数据删除）

**视图的作用，视图可以更改么？**

左连接、右连接、内连接、全外连接

- 内连接（inner join）：取出两张表中匹配到的数据，匹配不到的不保留
- 外连接（outer join）：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL

> todo
示例表

## 数据库引擎

sql执行顺序

(1)from 
(3) join 
(2) on 
(4) where 
(5)group by(开始使用select中的别名，后面的语句中都可以使用)
(6) avg,sum.... 
(7)having 
(8) select 
(9) distinct 
(10) order by 

**一条sql语句执行的过程？mysql逻辑架构图？**

**bin log 、undo log、 redo log**

+ bin log
+ undo log
+ redo log

**你知道的mysql数据库引擎有哪些？**

myisam，innodb，memory

**MyIsam和Innodb有什么区别？**

+ myisam是默认表类型不是事务安全的；innodb支持事务。
+ myisam不支持外键；Innodb支持外键。
+ myisam支持表级锁（不支持高并发，以读为主）；innodb支持行锁（共享锁，排它锁，意向锁），粒度更小，但是在执行不能确定扫描范围的sql语句时，innodb同样会锁全表
+ myisam使用非聚集索引，索引和数据分开，只缓存索引；innodb使用聚集索引，索引和数据存在一个文件

**MVCC机制说一下？**
> todo 图片

MVCC：多版本并发控制，是一种并发访问控制的方法。

在Innodb引擎中的RR（可重复读）这种隔离级别下进行读操作记录的过程就是MVCC。一种快照读。



可重复读就是，A事务先启动，B事务读数据修改数据，不会影响A事务的操作。

Innodb中MVCC的实现机制依赖两个隐藏字段：row trx_id roll_pointer

+ row trx_id就是一个记录编号，按照事务开启顺序递增
+ roll_pointer存了一个指针，记录上一个版本的位置，所以如果当前事务回滚，直接去找上一个版本的值就OK了，这个版本链就在undo日志中。





## 锁

**mysql有哪些锁？**



+ 粒度锁
  + 行锁
    + 上锁的时候锁住表的某一行或者几行记录，其他记录可以正常访问
  + 表锁
    + 锁住整张表
+ 算法锁（锁的算法）
  + 记录锁
    + 事务加锁以后锁住的只是表的某一条记录
    + 出现条件：精准条件命中，并且命中的条件字段是唯一索引
  + 间隙锁
    + 加锁以后锁住的是表记录的某一个区间
    + 出现的条件：范围查询并且查询未命中记录，查询条件必须命中索引，间隙锁只在RR事务级别中
    + 间隙锁可以防止幻读
  + 临键锁（Next-Key lock）
    + 记录锁和间隙锁的组合，把查询出来的记录锁住，同时把查询范围内所有的间隙锁住，与之相邻的下一个区间也锁住
    + 出现条件：范围查询并命中，查询命中了索引
    + 避免了查询出现脏读、重复读、幻读的问题
+ 属性锁
  + 共享锁
  + 排他锁
+ 状态锁（基于属性锁的状态）
  + 意向共享锁
  + 意向排他锁

**怎么解决幻读问题？**
> todo
+ next-key lock

**行锁、表锁说一下？**
> todo

**间隙锁？**
> todo

**乐观锁、悲观锁？**
> todo

**读锁、写锁？**
> todo

**两段锁？**
> todo


## 索引

**为什么一定要设一个主键？**
> todo

**你们主键是用自增还是UUID?**
> todo

**where执行顺序是怎样的？**
> todo

**索引是个什么样的数据结构呢?**

mysql有两种索引，hash索引和B+树索引

其它索引：全文索引，空间数据索引（R-tree）

**Hash索引和B+树索引有什么区别或者说优劣呢?**

+ hash
+ B-tree

**非聚簇索引一定会回表查询吗?**

不一定，联合索引万一有这个字段，就不用回表

**在建立索引的时候,都有哪些需要考虑的因素呢?**
> todo

**联合索引是什么?为什么需要注意联合索引中的顺序?**
> todo

**创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?**

explain，可以看到有没有走索引，走的哪个索引，扫描了多少数据

 **那么在哪些情况下会发生针对该列创建了索引但是在查询的时候并没有使用呢?**

+ 索引列参与计算或使用函数式运算
+ 前缀匹配原则，第一个索引列被跳过
+ 通配符开头
+ order by
  + 当order by 字段出现在where条件中时，才会利用索引而无需排序操作。其他情况，order by不会出现排序操作。 
  + 解决方案：建立联合索引
  + 如果查询联接了多个表，只有在order by子句的所有列引用的是第一个表的列才可以。

## 事务

**什么是事务?**

+ 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)
+ 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成

**ACID是什么?可以详细说一下吗?**

+ 原子性
  + 事务是最小单位，不可再分
+ 一致性
  + 必须同时成功或者失败
+ 隔离性
  + 两个事务之间具有隔离性
+ 持久性
  + 事务完成数据被持久化到硬盘中不会丢失

**同时有多个事务在进行会怎么样呢?**

与事务的隔离级别有关。可能会出现脏读、不可重复读、幻读等问题

**怎么解决这些问题呢?MySQL的事务隔离级别了解吗?**

+ 读未提交
  + 脏读
+ 读已提交
  + 不可重复读
+ 可重复读
  + 幻读
+ 序列化
  + 不会出现问题，但是效率低

## 优化

**关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?**
> todo

**字段为什么要求定义为not null?**
> todo