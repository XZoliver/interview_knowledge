**redis有哪几种类型？**

五大基本类型

+ string
  + 字符串对象底层数据结构实现为简单动态字符串（SDS）和直接存储，**但其编码方式可以是int、raw或者embstr，区别在于内存结构的不同**。
+ list
  + 在3.2版本之前，列表是使用ziplist和linkedlist实现的，在这些老版本中，当列表对象同时满足以下两个条件时，列表对象使用ziplist编码：

    + 列表对象保存的所有字符串元素的长度都小于64字节
    + 列表对象保存的元素数量小于512个
  + 当有任一条件 不满足时将会进行一次转码，使用linkedlist。
    
  + 双向链表
  + lpush+lpop=Stack(栈)
  + lpush+rpop=Queue（队列）
  + lpush+ltrim=Capped Collection（有限集合）
  + lpush+brpop=Message Queue（消息队列）
+ set
  + REDIS_ENCODING_INTSET
  + dict
+ zset
  + 两种存储方式
    + ziplist
      + 压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。
    + skiplist与dict的结合
+ hash
  + 在实现结构上它使用二维结构，第一维是数组，第二维是链表
  + 拉链法
  + **ziplist编码**
  + **hashtable编码**

**redis数据类型底层的结构是怎么样的？有哪些数据类型？**

五大数据类型以及底层实现：
- string
    - 底层实现：SDS（简单动态字符串），直接存储（直接编码存储）
- hash
    - 底层实现：拉链法实现的哈希表和ziplist（压缩列表）两种方式
- list
    - 底层实现: 双向链表和ziplist
- set
    - 底层实现：哈希表和intset
- zset
    - 底层实现：跳表和ziplist

**redis的hashtable实现和java的hashmap对比，有哪些特点与不同？**
> todo

- 渐进式rehash
- 扩容缩容负载因子的区别
- 红黑树

**redis跳表是什么结构？代码怎么实现？**
> todo

**redis通常有哪些使用场景？**
> todo
+ 缓存
+ 分布式锁

**redis持久化机制？有什么优劣？**
> todo
+ RDB
+ AOF

**redis事务是什么样的？**
> todo

**redis分布式锁怎么实现？**

主要依靠的命令：SETNX，如果存在则设置失败，如果不存在则设置成功

还需要一个过期时间和锁的续期，**watch dog自动延期机制**

在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。

**redis挂了怎么办？**

如果只有一台redis，那么存在单点故障，如果没有持久化的话那么数据会全部丢失，没办法抢救

所以需要redis sentinel，一个哨兵，或者扩展redis架构，使用redis集群

集群的三种方式：

+ 主从模式
  + 将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务
+ 哨兵模式
  + 哨兵的作用就是监控redis主、从数据库是否正常运行，主出现故障自动将从数据库转换为主数据库
+ 集群模式
  + 即每台redis存储不同的内容。
  + 集群至少需要3主3从，且每个实例使用不同的配置文件

**单线程的redis为什么这么快？**
> todo

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

**Redis 为什么是单线程的，优点？**
> todo

因为Redis是基于内存的操作，**CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽**。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

**Redis 集群方案应该怎么做？都有哪些方案？**
> todo
主从、哨兵、集群

**有没有尝试进行多机redis 的部署？如何保证数据一致的？**
> todo
主从复制，sync，rdb，快照

**为什么Redis的操作是原子性的，怎么保证原子性的？**

redis是单进程单线程模型，所以操作都是原子性的。

原子性定义：操作不可再分，要么成功要么失败

单线程下redis命令执行也就只有这两种情况，要么成功要么失败，而且一条命令不会拆成两步执行，所以是原子的

**讲解下Redis线程模型？**
> todo

**redis的过期策略以及内存淘汰机制？**
> todo

**如何保证redis和数据库数据的一致性？（ Cache Aside Pattern）**

https://www.cnblogs.com/myseries/p/12068845.html

+  Cache Aside Pattern
  + 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
  + 更新的时候，**先更新数据库，然后再删除缓存**。
+ 延时双删策略
  + 在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
+ 异步更新缓存(基于订阅binlog的同步机制)
  + 读Redis：热数据基本都在Redis
  + 写MySQL:增删改都是操作MySQL
  + 更新Redis数据：MySQL的数据操作binlog，来更新到Redis
  + mysql更新之后，redis订阅者收到更新通知，然后更新redis

**redis操作系统调用？**
> todo

**Redis、zookeeper的选举机制了解吗？**
> todo