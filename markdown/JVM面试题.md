# JVM面试

## JVM内存结构

**JDK1.7和JDK1.8永久代的变化？**

JDK1.7的永久代（Permgen）是一片连续的堆空间。永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。

方法区在HotSpot虚拟机也被称为**永久代**，也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常亮、静态变量、即时编译器变异后的代码等数据。

从JDK7开始永久代的移除工作，贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap，但是并没有被完全移除。主要的变动：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。

永久代在JDK8中被完全的移除了。JVM不再有PermGen。但类的元数据信息（metadata）还在，只不过不再是存储在连续的堆空间上，而是移动到叫做“Metaspace”的本地内存（Native memory）中。

元空间和永久代都是对JVM方法区的实现，区别在于元空间不在虚拟机中，而是使用本地内存，永久代

**JVM内存结构是怎么样的？**

+ 方法区

  + 非堆

  + 永久代是方法区的具体实现
  + 存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  + Native memory

+ 虚拟机栈
  + 线程私有，生命周期与线程相同
  + 一个方法的执行就是一个栈帧从入栈到出栈的过程
  + 栈帧的局部变量表就是存储的局部变量

+ 本地方法栈
  + 与虚拟机栈相似，区别是提供的字节码服务

+ 堆
  + 唯一的目的就是存放对象实例
  + TLAB
    + 每一个线程会有一块区域叫做TLAB，对象优先在TLAB上分配空间，如果TLAB装不下了，会有两种选择，一种是直接在堆上分配对象，另一种是回收整个TLAB，然后重新分配
  + 程序计数器
    + 线程私有，每个线程都有自己的程序计数器
    + 改变程序计数器的值来选取下一条要执行的指令
    + 如果􏰃程正在执行的是一Java，记录的是正在 执行的虚拟机字节码指令的地址;如果正在执行的是Native方法，值则为空(Undefined)

**有几种OOM？哪个区域不会发生OOM？**

程序计数器不会发生OOM，其他区域都会发生

虚拟机栈和本地方法栈溢出 StackOverflow

方法区溢出，运行时常量池溢出

本机内存直接溢出

堆溢出

**强、软、弱、虚引用以及他们的使用场景？**

+ 强 new Object(),不会被回收

+ 软 当即将OOM的时候，被标记为软引用的对象将被回收，如果回收了还是不够，则OOM（空间不够的时候清理）

+ 弱 无论GC状态是怎样的，只清理弱引用对象（不管空间够不够都清理）
+  虚 就是在对象被清理的时候发送一条通知

## JVM内存模型、线程安全、锁优化

**Happens-before**

结论：happens-before觉得着什么时候变量操作对你可见。

+ 程序次序规则： 在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作
   （**同一个线程中前面的所有写操作对后面的操作可见**）

+ 管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。
   （**如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）**）

+ volatile变量规则：对一个volatile变量的写操作happen—before后面（时间上）对该变量的读操作。
   （**如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）**）

+ 线程启动规则：Thread.start()方法happen—before调用用start的线程前的每一个操作。
   （**假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。**）

+ 线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
   (**线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。**)

+ 线程中断规则：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。
   (**线程t1写入的所有变量，调用Thread.interrupt()，被打断的线程t2，可以看到t1的全部操作**)

+ 对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。
   (**对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存同步到全部cache。**)

+ 传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。

**java线程的实现机制？**

实现线程的三种方式：内核线程实现、用户线程实现、混合实现，详见操作系统

Java线程的实现：1.2以前:“绿色线程”，用户线程实现的

​                               1.2以后:基于操作系统原生线程模型实现，取决于操作系统

**JVM内存模型是什么？**

**JVM内存模型为什么要这么设计？**

**volatile**

**volatile语义增强？final语义增强？**

**synchronized优化**

**锁消除？ **

**CAS指令以及其他线程安全的方法？**

## 类文件结构、类加载机制

**类初始化什么时候触发？**

**类加载过程？**

 + 加载

    + 查找字节流，并且据此创建类的过程。除字节数组以外，类、接口，需要借助类加载器来完成查找字节流的过程
    + 类加载器

      + BootStrapClassLoader
      + ExtensionClassLoader
      + ApplicationClassLoader

 + 连接

   将创建完成的类合并至Java虚拟机中，使之能够执行的过程

    + 验证
      	+ 确保被加载类满足JVM约束条件
    + 准备
      	+ 为被加载类静态字段分配内存
    + 解析
      	+ 符号引用：class文件被加载之前，无法知道其它方法、字段对应的具体地址，甚至不知道自己方法和字段的地址
       + 将符号引用转为实际引用

 + 初始化

   	+ 为标记为常量值的字段赋值

**类加载机制？**

**类加载器**

用于类加载的加载阶段，完成查找字节流的过程

+ 类加载器
   + BootStrapClassLoader
   + ExtensionClassLoader
   + ApplicationClassLoader

**用于实现类的加载动作。**

**内部类的存储方式？**

**双亲委派模型**

三个类加载器，总是先把类丢给自己的父类进行加载，如果父类加载了，直接返回，如果父类表示不加载，则自己来加载

**双亲委派模型可不可以破坏？**

可以，比如TOMCAT就破坏了双亲委派模型，首先自己加载，如果自己不能加载的，再丢给父加载器加载。

具体实现就是重写ClassLoader的findClass方法和loadClass方法

**为什么TOMCAT破坏双亲委派模型？**

1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。
2. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。
3. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。
4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。

如果使用双亲委派模型，很明显第一个问题就没法解决，因为双亲委派模型只会存在一个类，不会有两个相同的类同时存在

## 编译期优化

**Java泛型说一说？**

**自动装箱和拆箱是什么？**

**逃逸分析？**

**即时编译器的前后端优化方法？**

## 垃圾收集

**引用计数法和可达性分析？**

**垃圾收集算法有哪几种？**

+ 标记-整理
+ 标记-清除
+ 复制算法

**常见垃圾收集器有哪些？**

+ 新生代
+ 老年代
+ G1

**详细说说CMS和G1？**

**衡量GC的性能指标有哪些？**

**新生代和老年代，为什么要分代？**

**新生代对象怎么晋升老年代的？**

+ 默认晋升年龄：存活次数到了直接进入老年代。这个年龄可以是动态的，取决于JVM
+ S0,S1两个区域，如果目标区域被填满，则剩下的Eden区域的对象直接进入老年代
+ （Eden区装不下的）大对象也会直接进入老年代

**内存分配策略是怎样的？**

**MinorGC和FullGC是什么？什么场景下触发？**

**不同的GC策略适用的场景？**

**内存的哪些部分会参与GC的回收？**

## JVM调优

谈谈你是如何优化Java GC的？

你是怎么指定JVM启动模式？

那你知道-server和-client的区别吗？

你使用过Java虚拟机性能监控和故障处理工具吗？